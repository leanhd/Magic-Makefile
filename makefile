# Author Matthieu Sieben (http://matthieusieben.com)
# Version 23/10/2012
#
# This makefile is licensed under the Creative Commons Attribution
# Partage dans les MÃªmes Conditions 2.0 Belgique License.
# To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/2.0/be/.
# Use at your own risk.
#
# Use makefile.inc to write you own rules or to overwrite the default values defined here.

PROJECT		:= $(shell basename "$(CURDIR)")
VERSION		:= $(shell date "+%Y%m%d")

SRCDIR		:= ./src
BINDIR		:= ./bin

SHELL		:= /bin/bash
CC			?= gcc
CFLAGS		?=
LDFLAGS		?=

EXCLUDES	:= --exclude "*~" --exclude ".*"

# Phony rules
.PHONY: deps
.PHONY: default all exec
.PHONY: clean clean_obj clean_exec
.PHONY: dist distclean tar bz2
.PHONY: install install_exec uninstall uninstall_exec

# Make "all" the default target.
default: all
all: exec

# Inculde external rules
-include makefile.inc
-include makefile.deps

# Debugging is disabled by default
ifndef DEBUG
DEBUG := 0
endif

# Setup C flags
ifneq ($(DEBUG), 0)
	CFLAGS  += -ggdb -DVERSION="\"$(VERSION)\"" -DDEBUG=1
else
	CFLAGS  += -O3 -DVERSION="\"$(VERSION)\"" -DDEBUG=0
	LDFLAGS += -O3
endif

## Common macros

empty		:=
comma		:= ,
space		:= $(empty) $(empty)

FAIL_COLOR	:= $(shell tput setaf 1)
OK_COLOR	:= $(shell tput setaf 2)
INFO_COLOR	:= $(shell tput setaf 4)
RST_COLOR	:= $(shell tput sgr0)
NBR_COLUMNS	:= $(shell tput cols)

# Prints the message in $1, runs the command in $2 then prints DONE or FAILED
run_command = \
	msg="$(1)"; \
	padlen=$$(( $(NBR_COLUMNS) - $${\#msg} )); \
	echo -n "$$msg"; \
	output=$$({ $(2) } 2>&1; exit $$?;); \
	RETVAL=$$?; \
	if [ $$RETVAL -eq 0 ]; then \
		printf '%s%*s%s\n' "$(OK_COLOR)" $$padlen "[DONE]" "$(RST_COLOR)"; \
		if [ "$$output" != "" ]; then \
			echo " $(INFO_COLOR)[OUTPUT]$(RST_COLOR)" >&2; \
			echo "$$output" >&2; \
		fi; \
	else \
		printf '%s%*s%s\n' "$(FAIL_COLOR)" $$padlen "[FAILED]" "$(RST_COLOR)"; \
		echo " $(INFO_COLOR)[COMMAND]$(RST_COLOR)" >&2; \
		echo '$(subst ','"'"',$(2))' >&2; \
		echo " $(INFO_COLOR)[ERROR]$(RST_COLOR)" >&2; \
		echo "$$output" >&2; \
		echo >&2; \
		exit $$RETVAL; \
	fi;

# Creates the directory $1 (and prints a message)
create_dir = \
	@$(call run_command,Creating directory $(1),mkdir -p $(1); touch $(1);)

## Common rules

.SUFFIXES: .c .o
%.o: %.c
	@$(call run_command,  Compiling $<,$(CC) $(CFLAGS) -o $@ -c $<;)

clean: clean_obj clean_exec

clean_exec:
	@$(call run_command,Deleting executables,if [ -d $(BINDIR) ]; then rm -r $(BINDIR); fi;)

clean_obj:
	@$(call run_command,Deleting object files,find $(SRCDIR) -name "*.o" -exec rm {} \; ;)


$(BINDIR):
	@$(call create_dir,$@)

## Installation rules

install:
uninstall:

ifdef PREFIX
$(PREFIX):
	@$(call create_dir,$@)

ifndef INSTALL_BINDIR
INSTALL_BINDIR  = $(PREFIX)/bin
endif
endif

ifdef INSTALL_BINDIR

install: install_exec
uninstall: uninstall_exec

$(INSTALL_BINDIR):
	@$(call create_dir,$@)

ifndef INSTALL_BINS
INSTALL_BINS = $(shell $(MAKE) -f makefile.deps -pn | grep '^exec:' | cut -d: -f2 | sed -e 's/^[ ]*//g' -e 's/[ ]*$$//g')
endif

install_exec: $(INSTALL_BINS) |$(INSTALL_BINDIR)
	@$(call run_command,Installing binaries into $(INSTALL_BINDIR),for e in $(INSTALL_BINS); do cp $(BINDIR)/$$e $(INSTALL_BINDIR); done;)
uninstall_exec: makefile.deps
	@$(call run_command,Uninstalling binaries from $(INSTALL_BINDIR),for e in $(INSTALL_BINS); do rm -f $(INSTALL_BINDIR)/$$e; done;)

endif # INSTALL_BINDIR

## Distributables

dist: tar bz2
tar: makefile.deps clean
	@$(call run_command,  Creating ../$(PROJECT)_$(VERSION).tar.gz,tar -zco -C .. $(EXCLUDES) -f "../$(PROJECT)_$(VERSION).tar.gz" "$(shell basename $(CURDIR))";)

bz2: makefile.deps clean
	@$(call run_command,  Creating ../$(PROJECT)_$(VERSION).tar.bz2,tar -jco -C .. $(EXCLUDES) -f "../$(PROJECT)_$(VERSION).tar.bz2" "$(shell basename $(CURDIR))";)

distclean: clean
	@$(call run_command,Deleting dependencies file,rm -f makefile.deps;)
	@$(call run_command,Deleting dist files,rm -f ../$(PROJECT)_$(VERSION).tar.gz && rm -f ../$(PROJECT)_$(VERSION).tar.bz2;)

## Dependencies

deps:
	@$(call run_command,Building dependencies,eval $(build_dependencies_file))

makefile.deps:
	@$(call run_command,Building dependencies,eval $(build_dependencies_file))

build_dependencies_file = \
	TEMP_FILE=`mktemp /tmp/makefile.deps.XXXXXX`; \
	echo "\# WARNING" >> $$TEMP_FILE; \
	echo "\# This file was automatically generated by 'make deps'." >> $$TEMP_FILE; \
	echo "\# Any modification may be overwritten." >> $$TEMP_FILE; \
	echo >> $$TEMP_FILE; \
	C_FILES=`find $(SRCDIR) -type f -name "*.c"`; \
	for file in $$C_FILES; do \
		$(CC) $(CFLAGS) -MM -MT $${file/%.c/.o} $$file | tr -d "\\n\\\\" >> $$TEMP_FILE; \
		[ $${PIPESTATUS[0]} -ne 0 ] && rm -f $$TEMP_FILE && exit -1; \
		echo -e "\n" >> $$TEMP_FILE; \
	done; \
	main_files=`grep -Hs " main(" $$C_FILES | cut -f1 -d':'`; \
	for file in $$main_files; do \
		execname=`basename $$file .c`; \
		objs="$${file/%.c/.o} "; \
		until [ "$$tmp_objs" == "$$objs" ]; do \
			tmp_objs="$$objs"; \
			headers=`$(CC) $(CFLAGS) -MM $$file | tr " " "\\n" | grep ".h$$" | sort -u | tr "\\n" " "; exit $${PIPESTATUS[0]};`; \
			[ $$? -ne 0 ] && rm -f $$TEMP_FILE && exit -1; \
			headers+=" $${objs//.o[[:space:]]/.h }"; \
			for header in $$headers; do \
				if [ -f $${header/%.h/.c} ]; then \
					objs+="$${header/%.h/.o} "; \
				fi; \
				for sub_h in `grep "$${header/%.h/.o}:" $$TEMP_FILE | tr " " "\\n" | grep ".h$$" | tr "\\n" " "`; do \
					if [ -f $${sub_h/%.h/.c} ]; then \
						objs+="$${sub_h/%.h/.o} "; \
					fi; \
				done; \
			done; \
			objs="`echo -n $$objs | tr " " "\\n" | sed -e 's|^\\./||' -e 's|/\\./|/|g' -e ':a' -e 's|[^/]*/\\.\\./||' -e 't a' | sort -u | tr "\\n" " "` "; \
		done; \
		echo "exec: $$execname" >> $$TEMP_FILE; \
		echo "$$execname: \$$(BINDIR)/$$execname" >> $$TEMP_FILE; \
		echo "\$$(BINDIR)/$$execname: $$objs |\$$(BINDIR)" >> $$TEMP_FILE; \
		echo "	@\$$(call run_command, Linking \$$@,\$$(CC) \$$(LDFLAGS) -o \$$@ $$^;)" >> $$TEMP_FILE; \
		echo >> $$TEMP_FILE; \
	done; \
	cp $$TEMP_FILE makefile.deps; \
	rm $$TEMP_FILE; \
	exit 0;
